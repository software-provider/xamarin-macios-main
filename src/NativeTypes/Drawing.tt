// !!! WARNING - GENERATED CODE - DO NOT EDIT !!!
//
// Generated by Drawing.tt, a T4 template.
//
// Drawing.cs: basic types with 32 or 64 bit member sizes:
//
//   - CGSize { nfloat, nfloat }
//   - CGPoint { nfloat, nfloat }
//   - CGRect { nfloat, nfloat, nfloat, nfloat }
//
// If ARCH_32 is defined, the underlying types for n* types will be
// 32 bit (int, uint, float). If not defined, the underlying types
// will be 64 bit (long, ulong, double).
//
// Authors:
//   Aaron Bockover <abock@xamarin.com>
//   Miguel de Icaza <miguel@xamarin.com>
//
// Copyright 2020 Microsoft Corp. All Rights Reserved.
// Copyright 2013 Xamarin, Inc. All rights reserved.
//

<#@ template language="C#v3.5" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
using System;
#if !NO_SYSTEM_DRAWING
using System.Drawing;
#endif
using System.Globalization;
using System.Runtime.InteropServices;

using Foundation;
using ObjCRuntime;

namespace CoreGraphics
{
<#
	Func<string, string> ucfirst = s => Char.ToUpper (s [0]) + s.Substring (1);

	foreach (var type in new [] {
		new { Name = "CGPoint", SDFloatName = "PointF", SDIntName = "Point", ArgName = "point", X_Width = "x", Y_Height = "y" },
		new { Name = "CGSize", SDFloatName = "SizeF", SDIntName = "Size", ArgName = "size", X_Width = "width", Y_Height = "height" }
	}) {
#>
	[Serializable]
	public partial struct <#= type.Name #> : IEquatable<<#= type.Name #>>
	{
		public static readonly <#= type.Name #> Empty;

		public static bool operator == (<#= type.Name #> l, <#= type.Name #> r)
		{
			// the following version of Equals cannot be removed by the linker, while == can be
			return l.Equals (r);
		}

		public static bool operator != (<#= type.Name #> l, <#= type.Name #> r)
		{
			return l.<#= type.X_Width #> != r.<#= type.X_Width #> || l.<#= type.Y_Height #> != r.<#= type.Y_Height #>;
		}

		public static <#= type.Name #> operator + (<#= type.Name #> l, CGSize r)
		{
			return new <#= type.Name #> (l.<#= type.X_Width #> + r.Width, l.<#= type.Y_Height #> + r.Height);
		}

		public static <#= type.Name #> operator - (<#= type.Name #> l, CGSize r)
		{
			return new <#= type.Name #> (l.<#= type.X_Width #> - r.Width, l.<#= type.Y_Height #> - r.Height);
		}

#if !NO_SYSTEM_DRAWING
		public static implicit operator <#= type.Name #> (<#= type.SDFloatName #> <#= type.ArgName #>)
		{
			return new <#= type.Name #> (<#= String.Format ("{0}.{1}, {0}.{2}", type.ArgName,
				ucfirst (type.X_Width), ucfirst (type.Y_Height)) #>);
		}

		public static implicit operator <#= type.Name #> (<#= type.SDIntName #> <#= type.ArgName #>)
		{
			return new <#= type.Name #> (<#= String.Format ("{0}.{1}, {0}.{2}", type.ArgName,
				ucfirst (type.X_Width), ucfirst (type.Y_Height)) #>);
		}

		public static explicit operator <#= type.SDFloatName #> (<#= type.Name #> <#= type.ArgName #>)
		{
			return new <#= type.SDFloatName #> (<#= String.Format ("(float){0}.{1}, (float){0}.{2}", type.ArgName,
				ucfirst (type.X_Width), ucfirst (type.Y_Height)) #>);
		}

		public static explicit operator <#= type.SDIntName #> (<#= type.Name #> <#= type.ArgName #>)
		{
			return new <#= type.SDIntName #> (<#= String.Format ("(int){0}.{1}, (int){0}.{2}", type.ArgName,
				ucfirst (type.X_Width), ucfirst (type.Y_Height)) #>);
		}
#endif

<# if (type.Name == "CGPoint") { #>
		public static CGPoint Add (CGPoint point, CGSize size)
		{
			return point + size;
		}

		public static CGPoint Subtract (CGPoint point, CGSize size)
		{
			return point - size;
		}
<# } else { #>
		public static explicit operator CGPoint (CGSize size)
		{
			return new CGPoint (size.Width, size.Height);
		}

		public static CGSize Add (CGSize size1, CGSize size2)
		{
			return size1 + size2;
		}

		public static CGSize Subtract (CGSize size1, CGSize size2)
		{
			return size1 - size2;
		}
<# } #>

		nfloat <#= type.X_Width #>;
		nfloat <#= type.Y_Height #>;

		public nfloat <#= ucfirst (type.X_Width) #> {
			get { return <#= type.X_Width #>; }
			set { <#= type.X_Width #> = value; }
		}

		public nfloat <#= ucfirst (type.Y_Height) #> {
			get { return <#= type.Y_Height #>; }
			set { <#= type.Y_Height #> = value; }
		}

		public bool IsEmpty {
			get { return <#= type.X_Width #> == 0.0 && <#= type.Y_Height #> == 0.0; }
		}

		public <#= type.Name #> (nfloat <#= type.X_Width #>, nfloat <#= type.Y_Height #>)
		{
			this.<#= type.X_Width #> = <#= type.X_Width #>;
			this.<#= type.Y_Height #> = <#= type.Y_Height #>;
		}

		public <#= type.Name #> (double <#= type.X_Width #>, double <#= type.Y_Height #>)
		{
			this.<#= type.X_Width #> = (nfloat)<#= type.X_Width #>;
			this.<#= type.Y_Height #> = (nfloat)<#= type.Y_Height #>;
		}

		public <#= type.Name #> (float <#= type.X_Width #>, float <#= type.Y_Height #>)
		{
			this.<#= type.X_Width #> = <#= type.X_Width #>;
			this.<#= type.Y_Height #> = <#= type.Y_Height #>;
		}

		public <#= type.Name #> (<#= type.Name #> <#= type.ArgName #>)
		{
			this.<#= type.X_Width #> = <#= type.ArgName #>.<#= type.X_Width #>;
			this.<#= type.Y_Height #> = <#= type.ArgName #>.<#= type.Y_Height #>;
		}

#if !COREBUILD
		public static bool TryParse (NSDictionary dictionaryRepresentation, out <#= type.Name #> <#= type.ArgName #>)
		{
			if (dictionaryRepresentation is null) {
			   	<#= type.ArgName #> = Empty;
				return false;
			}
			return NativeDrawingMethods.<#= type.Name #>MakeWithDictionaryRepresentation (dictionaryRepresentation.Handle, out <#=type.ArgName#>);
		}

		public NSDictionary ToDictionary ()
		{
			return new NSDictionary (NativeDrawingMethods.<#=type.Name#>CreateDictionaryRepresentation (this));
		}
#endif

<# if (type.Name == "CGSize") { #>
		public CGSize (CGPoint point)
		{
			this.width = point.X;
			this.height = point.Y;
		}

<# } #>
		public override bool Equals (object obj)
		{
			return (obj is <#= type.Name #> t) && Equals (t);
		}

<# if (type.Name == "CGPoint") { #>
		public bool Equals (CGPoint point)
		{
			return point.<#= type.X_Width #> == <#= type.X_Width #> && point.<#= type.Y_Height #> == <#= type.Y_Height #>;
		}
<# } else { #>
		public bool Equals (CGSize size)
		{
			return size.<#= type.X_Width #> == <#= type.X_Width #> && size.<#= type.Y_Height #> == <#= type.Y_Height #>;
		}
<# } #>

#if !NET
		public override int GetHashCode ()
		{
			var hash = 23;
			hash = hash * 31 + <#= type.X_Width #>.GetHashCode ();
			hash = hash * 31 + <#= type.Y_Height #>.GetHashCode ();
			return hash;
		}
#endif

		public void Deconstruct (out nfloat <#= type.X_Width #>, out nfloat <#= type.Y_Height #>)
		{
			<#= type.X_Width #> = <#= ucfirst (type.X_Width) #>;
			<#= type.Y_Height #> = <#= ucfirst (type.Y_Height) #>;
		}

<# if (type.Name == "CGSize") { #>
		public CGSize ToRoundedCGSize ()
		{
			return new CGSize ((nfloat)Math.Round (width), (nfloat)Math.Round (height));
		}

#if !XAMCORE_3_0
		[Obsolete ("Use 'ToRoundedCGSize' instead.")]
		public CGSize ToSize ()
		{
			return ToRoundedCGSize ();
		}

		[Obsolete ("Use 'ToCGPoint' instead.")]
		public CGPoint ToPointF ()
		{
			return (CGPoint)this;
		}
#endif

		public CGPoint ToCGPoint ()
		{
			return (CGPoint)this;
		}

<# } #>
#if !NET
		public override string ToString ()
		{
			return String.Format ("{{<#= ucfirst (type.X_Width) #>={0}, <#= ucfirst (type.Y_Height) #>={1}}}",
				<#= type.X_Width #>.ToString (CultureInfo.CurrentCulture),
				<#= type.Y_Height #>.ToString (CultureInfo.CurrentCulture)
			);
		}
#endif
	}

<# } #>

	[Serializable]
	public partial struct CGRect : IEquatable<CGRect>
	{
		[Field ("CGRectZero", "CoreGraphics")] // unused but helps xtro
		public static readonly CGRect Empty;

#if !COREBUILD
		[Field ("CGRectNull", "CoreGraphics")] // unused but helps xtro
		public static CGRect Null {
			get { return Dlfcn.GetCGRect (Libraries.CoreGraphics.Handle, "CGRectNull"); }
		}

		[Field ("CGRectInfinite", "CoreGraphics")] // unused but helps xtro
		public static CGRect Infinite {
			get { return Dlfcn.GetCGRect (Libraries.CoreGraphics.Handle, "CGRectInfinite"); }
		}
#endif

		public static bool operator == (CGRect left, CGRect right)
		{
			// the following version of Equals cannot be removed by the linker, while == can be
			return left.Equals (right);
		}

		public static bool operator != (CGRect left, CGRect right)
		{
			return
				left.X != right.X ||
				left.Y != right.Y ||
				left.Width != right.Width ||
				left.Height != right.Height;
		}

#if !NO_SYSTEM_DRAWING
		public static implicit operator CGRect (RectangleF rect)
		{
			return new CGRect (rect.X, rect.Y, rect.Width, rect.Height);
		}

		public static implicit operator CGRect (Rectangle rect)
		{
			return new CGRect (rect.X, rect.Y, rect.Width, rect.Height);
		}

		public static explicit operator RectangleF (CGRect rect)
		{
			return new RectangleF ((float)rect.X, (float)rect.Y, (float)rect.Width, (float)rect.Height);
		}

		public static explicit operator Rectangle (CGRect rect)
		{
			return new Rectangle ((int)rect.X, (int)rect.Y, (int)rect.Width, (int)rect.Height);
		}
#endif

		public static CGRect Intersect (CGRect a, CGRect b)
		{
			// MS.NET returns a non-empty rectangle if the two rectangles
			// touch each other
			if (!a.IntersectsWithInclusive (b)) {
				return Empty;
			}

			return FromLTRB (
				(nfloat)Math.Max (a.Left, b.Left),
				(nfloat)Math.Max (a.Top, b.Top),
				(nfloat)Math.Min (a.Right, b.Right),
				(nfloat)Math.Min (a.Bottom, b.Bottom)
			);
		}

		public void Intersect (CGRect rect)
		{
			this = CGRect.Intersect (this, rect);
		}

		public static CGRect Union (CGRect a, CGRect b)
		{
			return FromLTRB (
				(nfloat)Math.Min (a.Left, b.Left),
				(nfloat)Math.Min (a.Top, b.Top),
				(nfloat)Math.Max (a.Right, b.Right),
				(nfloat)Math.Max (a.Bottom, b.Bottom)
			);
		}

		public static CGRect FromLTRB (nfloat left, nfloat top, nfloat right, nfloat bottom)
		{
			return new CGRect (left, top, right - left, bottom - top);
		}

		public static CGRect Inflate (CGRect rect, nfloat x, nfloat y)
		{
			var inflated = new CGRect (rect.X, rect.Y, rect.Width, rect.Height);
			inflated.Inflate (x, y);
			return inflated;
		}

		nfloat x;
		nfloat y;
		nfloat width;
		nfloat height;

		public bool IsEmpty {
			get { return width == 0.0 || height == 0.0; }
		}

		public nfloat X {
			get { return x; }
			set { x = value; }
		}

		public nfloat Y {
			get { return y; }
			set { y = value; }
		}

		public nfloat Width {
			get { return width; }
			set { width = value; }
		}

		public nfloat Height {
			get { return height; }
			set { height = value; }
		}

		public nfloat Top {
			get { return Y; }
		}

		public nfloat Bottom {
			get { return Y + Height; }
		}

		public nfloat Left {
			get { return X; }
		}

		public nfloat Right {
			get { return X + Width; }
		}

		public CGPoint Location {
			get { return new CGPoint (x, y); }
			set {
				x = value.X;
				y = value.Y;
			}
		}

		public CGSize Size {
			get { return new CGSize (width, height); }
			set {
				width = value.Width;
				height = value.Height;
			}
		}

		public CGRect (CGPoint location, CGSize size)
		{
			x = location.X;
			y = location.Y;
			width = size.Width;
			height = size.Height;
		}

		public CGRect (nfloat x, nfloat y, nfloat width, nfloat height)
		{
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
		}

		public CGRect (double x, double y, double width, double height)
		{
			this.x = (nfloat)x;
			this.y = (nfloat)y;
			this.width = (nfloat)width;
			this.height = (nfloat)height;
		}


		public CGRect (float x, float y, float width, float height)
		{
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
		}

		public bool Contains (nfloat x, nfloat y)
		{
			return
				x >= Left &&
				x < Right &&
				y >= Top &&
				y < Bottom;
		}

		public bool Contains (float x, float y)
		{
			return Contains ((nfloat) x, (nfloat) y);
		}

		public bool Contains (double x, double y)
		{
			return Contains ((nfloat) x, (nfloat) y);
		}

		public bool Contains (CGPoint point)
		{
			return Contains (point.X, point.Y);
		}

		public bool Contains (CGRect rect)
		{
			return
				X <= rect.X &&
				Right >= rect.Right &&
				Y <= rect.Y &&
				Bottom >= rect.Bottom;
		}

		public void Inflate (nfloat x, nfloat y)
		{
			this.x -= x;
			this.y -= y;
			width += x * 2;
			height += y * 2;
		}

		public void Inflate (float x, float y)
		{
			Inflate ((nfloat) x, (nfloat) y);
		}

		public void Inflate (double x, double y)
		{
			Inflate ((nfloat) x, (nfloat) y);
		}

		public void Inflate (CGSize size)
		{
			Inflate (size.Width, size.Height);
		}

		public void Offset (nfloat x, nfloat y)
		{
			X += x;
			Y += y;
		}

		public void Offset (float x, float y)
		{
			Offset ((nfloat) x, (nfloat) y);
		}

		public void Offset (double x, double y)
		{
			Offset ((nfloat) x, (nfloat) y);
		}

		public void Offset (CGPoint pos)
		{
			Offset (pos.X, pos.Y);
		}

		public bool IntersectsWith (CGRect rect)
		{
			return !(
				Left >= rect.Right ||
				Right <= rect.Left ||
				Top >= rect.Bottom ||
				Bottom <= rect.Top
			);
		}

		private bool IntersectsWithInclusive (CGRect r)
		{
			return !(
				Left > r.Right ||
				Right < r.Left ||
				Top > r.Bottom ||
				Bottom < r.Top
			);
		}

		public override bool Equals (object obj)
		{
			return (obj is CGRect rect) && Equals (rect);
		}

		public bool Equals (CGRect rect)
		{
			return
				x == rect.x &&
				y == rect.y &&
				width == rect.width &&
				height == rect.height;
		}

#if !NET
		public override int GetHashCode ()
		{
			var hash = 23;
			hash = hash * 31 + x.GetHashCode ();
			hash = hash * 31 + y.GetHashCode ();
			hash = hash * 31 + width.GetHashCode ();
			hash = hash * 31 + height.GetHashCode ();
			return hash;
		}

		public override string ToString ()
		{
			return String.Format ("{{X={0},Y={1},Width={2},Height={3}}}",
				x, y, width, height);
		}
#endif

		public void Deconstruct (out nfloat x, out nfloat y, out nfloat width, out nfloat height)
		{
			x = X;
			y = Y;
			width = Width;
			height = Height;
		}

		public void Deconstruct (out CGPoint location, out CGSize size)
		{
			location = Location;
			size = Size;
		}

#if !COREBUILD
		public static bool TryParse (NSDictionary dictionaryRepresentation, out CGRect rect)
		{
			if (dictionaryRepresentation is null) {
			   	rect = Empty;
				return false;
			}
			return NativeDrawingMethods.CGRectMakeWithDictionaryRepresentation (dictionaryRepresentation.Handle, out rect);
		}

		public NSDictionary ToDictionary ()
		{
			return new NSDictionary (NativeDrawingMethods.CGRectCreateDictionaryRepresentation (this));
		}
#endif
	}

#if !COREBUILD
	internal static class NativeDrawingMethods {
#if MONOMAC
		internal const string CG = Constants.ApplicationServicesCoreGraphicsLibrary;
#else
		internal const string CG = Constants.CoreGraphicsLibrary;
#endif
		[DllImport (CG)]
		[return: MarshalAs (UnmanagedType.I1)]
		internal extern static bool CGRectMakeWithDictionaryRepresentation (IntPtr dict, out CGRect rect);
		[DllImport (CG)]
		[return: MarshalAs (UnmanagedType.I1)]
		internal extern static bool CGPointMakeWithDictionaryRepresentation (IntPtr dict, out CGPoint point);
		[DllImport (CG)]
		[return: MarshalAs (UnmanagedType.I1)]
		internal extern static bool CGSizeMakeWithDictionaryRepresentation (IntPtr dict, out CGSize point);

		[DllImport (CG)]
		internal extern static IntPtr CGRectCreateDictionaryRepresentation (CGRect rect);
		[DllImport (CG)]
		internal extern static IntPtr CGSizeCreateDictionaryRepresentation (CGSize size);
		[DllImport (CG)]
		internal extern static IntPtr CGPointCreateDictionaryRepresentation (CGPoint point);
	}
#endif
}
